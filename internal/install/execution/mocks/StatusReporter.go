// Code generated by mockery v2.14.1. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	execution "github.com/newrelic/newrelic-cli/internal/install/execution"

	types "github.com/newrelic/newrelic-cli/internal/install/types"
)

// StatusReporter is an autogenerated mock type for the StatusReporter type
type StatusReporter struct {
	mock.Mock
}

type StatusReporter_Expecter struct {
	mock *mock.Mock
}

func (_m *StatusReporter) EXPECT() *StatusReporter_Expecter {
	return &StatusReporter_Expecter{mock: &_m.Mock}
}

// DiscoveryComplete provides a mock function with given fields: status, dm
func (_m *StatusReporter) DiscoveryComplete(status *execution.InstallStatus, dm types.DiscoveryManifest) error {
	ret := _m.Called(status, dm)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, types.DiscoveryManifest) error); ok {
		r0 = rf(status, dm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_DiscoveryComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DiscoveryComplete'
type StatusReporter_DiscoveryComplete_Call struct {
	*mock.Call
}

// DiscoveryComplete is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - dm types.DiscoveryManifest
func (_e *StatusReporter_Expecter) DiscoveryComplete(status interface{}, dm interface{}) *StatusReporter_DiscoveryComplete_Call {
	return &StatusReporter_DiscoveryComplete_Call{Call: _e.mock.On("DiscoveryComplete", status, dm)}
}

func (_c *StatusReporter_DiscoveryComplete_Call) Run(run func(status *execution.InstallStatus, dm types.DiscoveryManifest)) *StatusReporter_DiscoveryComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(types.DiscoveryManifest))
	})
	return _c
}

func (_c *StatusReporter_DiscoveryComplete_Call) Return(_a0 error) *StatusReporter_DiscoveryComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

// InstallCanceled provides a mock function with given fields: status
func (_m *StatusReporter) InstallCanceled(status *execution.InstallStatus) error {
	ret := _m.Called(status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus) error); ok {
		r0 = rf(status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_InstallCanceled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstallCanceled'
type StatusReporter_InstallCanceled_Call struct {
	*mock.Call
}

// InstallCanceled is a helper method to define mock.On call
//   - status *execution.InstallStatus
func (_e *StatusReporter_Expecter) InstallCanceled(status interface{}) *StatusReporter_InstallCanceled_Call {
	return &StatusReporter_InstallCanceled_Call{Call: _e.mock.On("InstallCanceled", status)}
}

func (_c *StatusReporter_InstallCanceled_Call) Run(run func(status *execution.InstallStatus)) *StatusReporter_InstallCanceled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus))
	})
	return _c
}

func (_c *StatusReporter_InstallCanceled_Call) Return(_a0 error) *StatusReporter_InstallCanceled_Call {
	_c.Call.Return(_a0)
	return _c
}

// InstallComplete provides a mock function with given fields: status
func (_m *StatusReporter) InstallComplete(status *execution.InstallStatus) error {
	ret := _m.Called(status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus) error); ok {
		r0 = rf(status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_InstallComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstallComplete'
type StatusReporter_InstallComplete_Call struct {
	*mock.Call
}

// InstallComplete is a helper method to define mock.On call
//   - status *execution.InstallStatus
func (_e *StatusReporter_Expecter) InstallComplete(status interface{}) *StatusReporter_InstallComplete_Call {
	return &StatusReporter_InstallComplete_Call{Call: _e.mock.On("InstallComplete", status)}
}

func (_c *StatusReporter_InstallComplete_Call) Run(run func(status *execution.InstallStatus)) *StatusReporter_InstallComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus))
	})
	return _c
}

func (_c *StatusReporter_InstallComplete_Call) Return(_a0 error) *StatusReporter_InstallComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

// InstallStarted provides a mock function with given fields: status
func (_m *StatusReporter) InstallStarted(status *execution.InstallStatus) error {
	ret := _m.Called(status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus) error); ok {
		r0 = rf(status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_InstallStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstallStarted'
type StatusReporter_InstallStarted_Call struct {
	*mock.Call
}

// InstallStarted is a helper method to define mock.On call
//   - status *execution.InstallStatus
func (_e *StatusReporter_Expecter) InstallStarted(status interface{}) *StatusReporter_InstallStarted_Call {
	return &StatusReporter_InstallStarted_Call{Call: _e.mock.On("InstallStarted", status)}
}

func (_c *StatusReporter_InstallStarted_Call) Run(run func(status *execution.InstallStatus)) *StatusReporter_InstallStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus))
	})
	return _c
}

func (_c *StatusReporter_InstallStarted_Call) Return(_a0 error) *StatusReporter_InstallStarted_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeAvailable provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeAvailable(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeAvailable'
type StatusReporter_RecipeAvailable_Call struct {
	*mock.Call
}

// RecipeAvailable is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeAvailable(status interface{}, event interface{}) *StatusReporter_RecipeAvailable_Call {
	return &StatusReporter_RecipeAvailable_Call{Call: _e.mock.On("RecipeAvailable", status, event)}
}

func (_c *StatusReporter_RecipeAvailable_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeAvailable_Call) Return(_a0 error) *StatusReporter_RecipeAvailable_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeCanceled provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeCanceled(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeCanceled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeCanceled'
type StatusReporter_RecipeCanceled_Call struct {
	*mock.Call
}

// RecipeCanceled is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeCanceled(status interface{}, event interface{}) *StatusReporter_RecipeCanceled_Call {
	return &StatusReporter_RecipeCanceled_Call{Call: _e.mock.On("RecipeCanceled", status, event)}
}

func (_c *StatusReporter_RecipeCanceled_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeCanceled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeCanceled_Call) Return(_a0 error) *StatusReporter_RecipeCanceled_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeDetected provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeDetected(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeDetected'
type StatusReporter_RecipeDetected_Call struct {
	*mock.Call
}

// RecipeDetected is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeDetected(status interface{}, event interface{}) *StatusReporter_RecipeDetected_Call {
	return &StatusReporter_RecipeDetected_Call{Call: _e.mock.On("RecipeDetected", status, event)}
}

func (_c *StatusReporter_RecipeDetected_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeDetected_Call) Return(_a0 error) *StatusReporter_RecipeDetected_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeFailed provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeFailed(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeFailed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeFailed'
type StatusReporter_RecipeFailed_Call struct {
	*mock.Call
}

// RecipeFailed is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeFailed(status interface{}, event interface{}) *StatusReporter_RecipeFailed_Call {
	return &StatusReporter_RecipeFailed_Call{Call: _e.mock.On("RecipeFailed", status, event)}
}

func (_c *StatusReporter_RecipeFailed_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeFailed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeFailed_Call) Return(_a0 error) *StatusReporter_RecipeFailed_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeInstalled provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeInstalled(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeInstalled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeInstalled'
type StatusReporter_RecipeInstalled_Call struct {
	*mock.Call
}

// RecipeInstalled is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeInstalled(status interface{}, event interface{}) *StatusReporter_RecipeInstalled_Call {
	return &StatusReporter_RecipeInstalled_Call{Call: _e.mock.On("RecipeInstalled", status, event)}
}

func (_c *StatusReporter_RecipeInstalled_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeInstalled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeInstalled_Call) Return(_a0 error) *StatusReporter_RecipeInstalled_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeInstalling provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeInstalling(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeInstalling_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeInstalling'
type StatusReporter_RecipeInstalling_Call struct {
	*mock.Call
}

// RecipeInstalling is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeInstalling(status interface{}, event interface{}) *StatusReporter_RecipeInstalling_Call {
	return &StatusReporter_RecipeInstalling_Call{Call: _e.mock.On("RecipeInstalling", status, event)}
}

func (_c *StatusReporter_RecipeInstalling_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeInstalling_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeInstalling_Call) Return(_a0 error) *StatusReporter_RecipeInstalling_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeRecommended provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeRecommended(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeRecommended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeRecommended'
type StatusReporter_RecipeRecommended_Call struct {
	*mock.Call
}

// RecipeRecommended is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeRecommended(status interface{}, event interface{}) *StatusReporter_RecipeRecommended_Call {
	return &StatusReporter_RecipeRecommended_Call{Call: _e.mock.On("RecipeRecommended", status, event)}
}

func (_c *StatusReporter_RecipeRecommended_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeRecommended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeRecommended_Call) Return(_a0 error) *StatusReporter_RecipeRecommended_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeSkipped provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeSkipped(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeSkipped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeSkipped'
type StatusReporter_RecipeSkipped_Call struct {
	*mock.Call
}

// RecipeSkipped is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeSkipped(status interface{}, event interface{}) *StatusReporter_RecipeSkipped_Call {
	return &StatusReporter_RecipeSkipped_Call{Call: _e.mock.On("RecipeSkipped", status, event)}
}

func (_c *StatusReporter_RecipeSkipped_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeSkipped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeSkipped_Call) Return(_a0 error) *StatusReporter_RecipeSkipped_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipeUnsupported provides a mock function with given fields: status, event
func (_m *StatusReporter) RecipeUnsupported(status *execution.InstallStatus, event execution.RecipeStatusEvent) error {
	ret := _m.Called(status, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, execution.RecipeStatusEvent) error); ok {
		r0 = rf(status, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipeUnsupported_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipeUnsupported'
type StatusReporter_RecipeUnsupported_Call struct {
	*mock.Call
}

// RecipeUnsupported is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - event execution.RecipeStatusEvent
func (_e *StatusReporter_Expecter) RecipeUnsupported(status interface{}, event interface{}) *StatusReporter_RecipeUnsupported_Call {
	return &StatusReporter_RecipeUnsupported_Call{Call: _e.mock.On("RecipeUnsupported", status, event)}
}

func (_c *StatusReporter_RecipeUnsupported_Call) Run(run func(status *execution.InstallStatus, event execution.RecipeStatusEvent)) *StatusReporter_RecipeUnsupported_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].(execution.RecipeStatusEvent))
	})
	return _c
}

func (_c *StatusReporter_RecipeUnsupported_Call) Return(_a0 error) *StatusReporter_RecipeUnsupported_Call {
	_c.Call.Return(_a0)
	return _c
}

// RecipesSelected provides a mock function with given fields: status, recipes
func (_m *StatusReporter) RecipesSelected(status *execution.InstallStatus, recipes []types.OpenInstallationRecipe) error {
	ret := _m.Called(status, recipes)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus, []types.OpenInstallationRecipe) error); ok {
		r0 = rf(status, recipes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_RecipesSelected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecipesSelected'
type StatusReporter_RecipesSelected_Call struct {
	*mock.Call
}

// RecipesSelected is a helper method to define mock.On call
//   - status *execution.InstallStatus
//   - recipes []types.OpenInstallationRecipe
func (_e *StatusReporter_Expecter) RecipesSelected(status interface{}, recipes interface{}) *StatusReporter_RecipesSelected_Call {
	return &StatusReporter_RecipesSelected_Call{Call: _e.mock.On("RecipesSelected", status, recipes)}
}

func (_c *StatusReporter_RecipesSelected_Call) Run(run func(status *execution.InstallStatus, recipes []types.OpenInstallationRecipe)) *StatusReporter_RecipesSelected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus), args[1].([]types.OpenInstallationRecipe))
	})
	return _c
}

func (_c *StatusReporter_RecipesSelected_Call) Return(_a0 error) *StatusReporter_RecipesSelected_Call {
	_c.Call.Return(_a0)
	return _c
}

// UpdateRequired provides a mock function with given fields: status
func (_m *StatusReporter) UpdateRequired(status *execution.InstallStatus) error {
	ret := _m.Called(status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*execution.InstallStatus) error); ok {
		r0 = rf(status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatusReporter_UpdateRequired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRequired'
type StatusReporter_UpdateRequired_Call struct {
	*mock.Call
}

// UpdateRequired is a helper method to define mock.On call
//   - status *execution.InstallStatus
func (_e *StatusReporter_Expecter) UpdateRequired(status interface{}) *StatusReporter_UpdateRequired_Call {
	return &StatusReporter_UpdateRequired_Call{Call: _e.mock.On("UpdateRequired", status)}
}

func (_c *StatusReporter_UpdateRequired_Call) Run(run func(status *execution.InstallStatus)) *StatusReporter_UpdateRequired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*execution.InstallStatus))
	})
	return _c
}

func (_c *StatusReporter_UpdateRequired_Call) Return(_a0 error) *StatusReporter_UpdateRequired_Call {
	_c.Call.Return(_a0)
	return _c
}

type mockConstructorTestingTNewStatusReporter interface {
	mock.TestingT
	Cleanup(func())
}

// NewStatusReporter creates a new instance of StatusReporter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStatusReporter(t mockConstructorTestingTNewStatusReporter) *StatusReporter {
	mock := &StatusReporter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
